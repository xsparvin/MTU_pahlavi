<!DOCTYPE html>
<html lang="fa">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MTU Tester by xsparvin (Fixed & Futuristic)</title>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

    :root {
      --bg: linear-gradient(135deg, #0d1222, #1a233a);
      --card: rgba(24, 35, 61, 0.8);
      --text: #e0e9ff;
      --muted: #a1b2c9;
      --accent: #00e0ff;
      --accent-secondary: #ff00e0;
      --glow-color: rgba(0, 224, 255, 0.6);
      --glow-secondary: rgba(255, 0, 224, 0.6);
      --glass: rgba(255, 255, 255, 0.1);
      --input-bg: rgba(0, 0, 0, 0.4);
      --shadow: 0 12px 40px rgba(0, 0, 0, 0.7), 0 0 20px rgba(0, 224, 255, 0.2);
      --border-radius: 24px;
      --transition: all 0.4s ease-in-out;
    }
    .light-theme {
      --bg: linear-gradient(135deg, #eef3ff, #d9e3ff);
      --card: rgba(255, 255, 255, 0.9);
      --text: #1a202c;
      --muted: #64748b;
      --accent: #0084ff;
      --accent-secondary: #ff0084;
      --glow-color: rgba(0, 132, 255, 0.3);
      --glow-secondary: rgba(255, 0, 132, 0.3);
      --glass: rgba(0, 0, 0, 0.08);
      --input-bg: #f8fafc;
      --shadow: 0 12px 40px rgba(0, 0, 0, 0.15), 0 0 20px rgba(0, 132, 255, 0.1);
    }

    body {
      margin: 0;
      padding: 32px;
      font-family: "Inter", sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      transition: var(--transition);
      overflow-x: hidden;
      position: relative;
    }
    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 50% 50%, rgba(0, 224, 255, 0.1), transparent 50%);
      opacity: 0.5;
      z-index: -1;
      animation: pulse 10s infinite alternate;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      100% { transform: scale(1.05); }
    }
    .wrap {
      max-width: 960px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }
    h1 {
      font-size: 32px;
      margin: 0 0 16px;
      font-weight: 800;
      color: var(--accent);
      text-shadow: 0 0 12px var(--glow-color), 0 0 4px var(--glow-secondary);
      text-align: center;
      letter-spacing: 1px;
      animation: neon-glow 2s ease-in-out infinite alternate;
    }
    @keyframes neon-glow {
      from { text-shadow: 0 0 8px var(--glow-color); }
      to { text-shadow: 0 0 16px var(--glow-color), 0 0 8px var(--glow-secondary); }
    }
    .card {
      background: var(--card);
      border: 1px solid var(--glass);
      padding: 32px;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(16px);
      margin-bottom: 32px;
      animation: fadeInScale 0.8s ease;
      transition: var(--transition);
    }
    .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 16px 50px rgba(0, 0, 0, 0.8), 0 0 30px var(--glow-color);
    }
    @keyframes fadeInScale {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }
    label {
      display: block;
      font-size: 15px;
      color: var(--muted);
      margin-bottom: 8px;
      font-weight: 600;
    }
    input[type="text"] {
      width: 100%;
      padding: 16px;
      border-radius: 16px;
      background: var(--input-bg);
      border: 1px solid var(--glass);
      color: var(--text);
      font-size: 16px;
      box-sizing: border-box;
      transition: var(--transition);
    }
    input[type="text"]:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 8px var(--glow-color), 0 0 4px var(--glow-secondary);
      background: rgba(255, 255, 255, 0.05);
    }
    button {
      padding: 14px 24px;
      border-radius: 16px;
      border: none;
      cursor: pointer;
      background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
      color: var(--bg);
      font-weight: 700;
      transition: var(--transition);
      position: relative;
      overflow: hidden;
    }
    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 200%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }
    button:hover::before {
      left: 100%;
    }
    button:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 0 20px var(--glow-color), 0 8px 24px rgba(0,0,0,0.4);
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    #auto {
      background: linear-gradient(135deg, var(--glass), var(--glass)) !important;
      color: var(--text) !important;
      border: 1px solid var(--muted) !important;
    }
    #auto:hover:not(:disabled) {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1)) !important;
      box-shadow: 0 0 15px var(--glow-secondary);
    }
    .live-box {
      margin-top: 24px;
      border: 1px solid var(--glass);
      border-radius: 16px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.15);
      transition: var(--transition);
      box-shadow: inset 0 0 10px rgba(0, 224, 255, 0.1);
    }
    .status {
      font-size: 15px;
      margin-top: 8px;
      transition: color 0.3s;
    }
    .status-default { color: var(--muted); }
    .status-ok { color: #66ffb8; text-shadow: 0 0 5px rgba(102, 255, 184, 0.5); }
    .status-err { color: #ff7b7b; text-shadow: 0 0 5px rgba(255, 123, 123, 0.5); }
    .status-loading { color: #ffe57a; animation: loading-pulse 1.5s infinite; }
    @keyframes loading-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    pre {
      background: rgba(0,0,0,0.25);
      padding: 20px;
      border-radius: 16px;
      overflow-x: auto;
      color: var(--accent);
      border: 1px solid var(--glass);
      font-size: 14px;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 24px;
      font-size: 15px;
      table-layout: fixed;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 0 15px var(--glow-color);
    }
    th, td {
      padding: 16px;
      border-bottom: 1px solid var(--glass);
      text-align: left;
      transition: background 0.3s;
    }
    tr:hover {
      background: rgba(255,255,255,0.05);
    }
    .result-success { color: #66ffb8; font-weight: 600; }
    .result-failure { color: #ff7b7b; font-weight: 600; }
    .result-unknown { color: var(--muted); }
    .controls {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      margin-bottom: 24px;
    }
    .control-btn {
      padding: 10px 16px;
      border-radius: 12px;
      background: var(--glass);
      color: var(--text);
      cursor: pointer;
      font-size: 15px;
      border: 1px solid var(--muted);
      transition: var(--transition);
    }
    .control-btn:hover {
      background: rgba(255,255,255,0.2);
      box-shadow: 0 0 10px var(--glow-color);
      transform: scale(1.05);
    }
    footer {
      margin-top: 32px;
      font-size: 14px;
      color: var(--muted);
      text-align: center;
      opacity: 0.8;
      transition: opacity 0.3s;
    }
    footer:hover {
      opacity: 1;
    }
    footer a {
      color: var(--accent);
      text-decoration: none;
      transition: color 0.3s;
    }
    footer a:hover {
      color: var(--accent-secondary);
      text-shadow: 0 0 5px var(--glow-secondary);
    }
    @media (max-width: 600px) {
      body { padding: 16px; }
      .card { padding: 24px; }
      h1 { font-size: 28px; }
      .button-group { flex-direction: column; gap: 12px !important; margin-top: 16px !important; }
      .button-group button { width: 100%; padding: 14px 0; }
      .controls { justify-content: space-between; }
      table { display: block; overflow-x: auto; white-space: nowrap; }
      th, td { min-width: 120px; }
    }
  </style>
</head>
<body>
<div class="wrap">

  <div class="controls">
    <div id="languageToggle" class="control-btn" data-lang="fa">EN / FA</div>
    <div id="themeToggle" class="control-btn">ğŸ’¡ / ğŸŒ™</div>
  </div>

  <h1 id="appTitle">ØªØ³ØªØ± MTU</h1>

  <div class="card">
    <label id="labelSize">Ø§Ù†Ø¯Ø§Ø²Ù‡ Ø¨Ø§Ø± Ù…ÙÛŒØ¯ (Ø¨Ø§ÛŒØª)</label>
    <input id="size" type="text" value="1400" />

    <div class="button-group" style="margin-top:14px;display:flex;gap:12px;flex-wrap:wrap;">
      <button id="run">Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øª</button>
      <button id="auto">ØªØ³Øª Ø®ÙˆØ¯Ú©Ø§Ø± Ú†Ù†Ø¯Ú¯Ø§Ù†Ù‡</button>
    </div>

    <div class="live-box" id="liveBox">
      <strong id="strongStatus">ÙˆØ¶Ø¹ÛŒØª Ù„Ø­Ø¸Ù‡â€ŒØ§ÛŒ:</strong>
      <div id="liveStatus" class="status status-default">Ù‡Ù†ÙˆØ² ØªØ³ØªÛŒ Ø§Ù†Ø¬Ø§Ù… Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª</div>
    </div>

    <table id="results">
      <thead>
        <tr>
          <th id="thSize">Ø§Ù†Ø¯Ø§Ø²Ù‡</th>
          <th id="thResult">Ù†ØªÛŒØ¬Ù‡</th>
          <th id="thTime">Ø²Ù…Ø§Ù† (Ù…ÛŒÙ„ÛŒâ€ŒØ«Ø§Ù†ÛŒÙ‡)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="card">
    <h3 id="h3Accurate">Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ù‚ÛŒÙ‚ MTU (Ø±ÙˆØ´ ÙˆØ§Ù‚Ø¹ÛŒ)</h3>
    <p id="pAccurate" style="font-size:14px;color:var(--muted);">
      <strong>ØªÙˆØ¬Ù‡:</strong> Ø§ÛŒÙ† Ø§Ø¨Ø²Ø§Ø± MTU Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ù…Ø³ØªÙ‚ÛŒÙ… ØªØ³Øª Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯ØŒ Ø¨Ù„Ú©Ù‡ Ø§Ù†Ø¯Ø§Ø²Ù‡ Ø¨Ø³ØªÙ‡ Ù‚Ø§Ø¨Ù„ Ø¹Ø¨ÙˆØ± Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.
      Ø¨Ø±Ø§ÛŒ ØªØ³Øª ÙˆØ§Ù‚Ø¹ÛŒ MTU Ø¨Ø§ÛŒØ¯ Ø§Ø² Ø¯Ø³ØªÙˆØ±Ø§Øª Ø²ÛŒØ± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯:
    </p>
<pre>
Linux:
  ping -M do -s &lt;PAYLOAD&gt; host

macOS:
  ping -D -s &lt;PAYLOAD&gt; host

Windows:
  ping -f -l &lt;PAYLOAD&gt; host

ÙØ±Ù…ÙˆÙ„:
  MTU = payload + 28 (IP header + ICMP header)
  MTU ÙˆØ§Ù‚Ø¹ÛŒ Ø´Ø¨Ú©Ù‡ Ø´Ù…Ø§ = Ø¨Ø²Ø±Ú¯ØªØ±ÛŒÙ† payload Ù…ÙˆÙÙ‚ + 28
</pre>
    <div id="currentResults" style="margin-top: 16px; padding: 12px; background: rgba(0,0,0,0.1); border-radius: 8px;">
      <h4 style="margin: 0 0 8px 0; color: var(--accent);">Ù†ØªØ§ÛŒØ¬ ÙØ¹Ù„ÛŒ:</h4>
      <div id="summaryText">Ù‡Ù†ÙˆØ² ØªØ³ØªÛŒ Ø§Ù†Ø¬Ø§Ù… Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.</div>
      <div id="recommendedMTU" style="margin-top: 8px; font-weight: bold; color: var(--accent);"></div>
    </div>
  </div>

  <footer>
    Made by xsparvin | Channel: <a href="https://t.me/xsfsociety" target="_blank">t.me/xsfsociety</a>
  </footer>
</div>

<script>
(function(){
  // -------------- Translations (fa / en)
  const translations = {
    fa: {
      appTitle: "ØªØ³ØªØ± MTU",
      labelSize: "Ø§Ù†Ø¯Ø§Ø²Ù‡ Ø¨Ø§Ø± Ù…ÙÛŒØ¯ (Ø¨Ø§ÛŒØª)",
      run: "Ø§Ø¬Ø±Ø§ÛŒ ØªØ³Øª",
      auto: "ØªØ³Øª Ø®ÙˆØ¯Ú©Ø§Ø± Ú†Ù†Ø¯Ú¯Ø§Ù†Ù‡",
      strongStatus: "ÙˆØ¶Ø¹ÛŒØª Ù„Ø­Ø¸Ù‡â€ŒØ§ÛŒ:",
      statusNoTest: "Ù‡Ù†ÙˆØ² ØªØ³ØªÛŒ Ø§Ù†Ø¬Ø§Ù… Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª",
      thSize: "Ø§Ù†Ø¯Ø§Ø²Ù‡",
      thResult: "Ù†ØªÛŒØ¬Ù‡",
      thTime: "Ø²Ù…Ø§Ù† (Ù…ÛŒÙ„ÛŒâ€ŒØ«Ø§Ù†ÛŒÙ‡)",
      h3Accurate: "Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ù‚ÛŒÙ‚ MTU (Ø±ÙˆØ´ ÙˆØ§Ù‚Ø¹ÛŒ)",
      pAccurate: "ØªÙˆØ¬Ù‡: Ø§ÛŒÙ† Ø§Ø¨Ø²Ø§Ø± MTU Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ù…Ø³ØªÙ‚ÛŒÙ… ØªØ³Øª Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯ØŒ Ø¨Ù„Ú©Ù‡ Ø§Ù†Ø¯Ø§Ø²Ù‡ Ø¨Ø³ØªÙ‡ Ù‚Ø§Ø¨Ù„ Ø¹Ø¨ÙˆØ± Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯. Ø¨Ø±Ø§ÛŒ ØªØ³Øª ÙˆØ§Ù‚Ø¹ÛŒ MTU Ø¨Ø§ÛŒØ¯ Ø§Ø² Ø¯Ø³ØªÙˆØ±Ø§Øª Ø²ÛŒØ± Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯:",
      statusTesting: (size) => `Ø¯Ø±Ø­Ø§Ù„ ØªØ³Øª ${size} Ø¨Ø§ÛŒØª...`,
      statusSuccess: (size) => `Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø±Ø§ÛŒ ${size} Ø¨Ø§ÛŒØª`,
      statusNetworkError: "Ø®Ø·Ø§ÛŒ Ø´Ø¨Ú©Ù‡ / Ø¹Ø¯Ù… ØªØ·Ø§Ø¨Ù‚ Ø§Ù†Ø¯Ø§Ø²Ù‡",
      statusComplete: "ØªØ³Øª Ø®ÙˆØ¯Ú©Ø§Ø± Ú©Ø§Ù…Ù„ Ø´Ø¯",
      statusInvalidInput: "ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±",
      summaryNoTests: "Ù‡Ù†ÙˆØ² ØªØ³ØªÛŒ Ø§Ù†Ø¬Ø§Ù… Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.",
      summaryTestsDone: "ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯Ù‡: {{total}} | Ù…ÙˆÙÙ‚: {{success}} | Ù†Ø§Ù…ÙˆÙÙ‚: {{failed}}",
      recommendedMTU: "Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ MTU: {{mtu}} (Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¨Ø²Ø±Ú¯ØªØ±ÛŒÙ† payload Ù…ÙˆÙÙ‚: {{payload}} Ø¨Ø§ÛŒØª)"
    },
    en: {
      appTitle: "MTU Tester",
      labelSize: "Payload Size (bytes)",
      run: "Run Test",
      auto: "Auto Multi-Test",
      strongStatus: "Live Status:",
      statusNoTest: "No test yet",
      thSize: "Size",
      thResult: "Result",
      thTime: "Time (ms)",
      h3Accurate: "Accurate MTU Check (Real Method)",
      pAccurate: "Note: This tool does not test MTU directly, but checks the passable packet size. Use these commands for real MTU testing:",
      statusTesting: (size) => `Testing ${size} bytes...`,
      statusSuccess: (size) => `Success for ${size} bytes`,
      statusNetworkError: "Network Error / Size Mismatch",
      statusComplete: "Auto Test Complete",
      statusInvalidInput: "Invalid input",
      summaryNoTests: "No tests performed yet.",
      summaryTestsDone: "Tests done: {{total}} | Success: {{success}} | Failed: {{failed}}",
      recommendedMTU: "Recommended MTU: {{mtu}} (based on largest successful payload: {{payload}} bytes)"
    }
  };

  // DOM refs
  const elementsToTranslate = {
    appTitle: document.getElementById('appTitle'),
    labelSize: document.getElementById('labelSize'),
    run: document.getElementById('run'),
    auto: document.getElementById('auto'),
    strongStatus: document.getElementById('strongStatus'),
    thSize: document.getElementById('thSize'),
    thResult: document.getElementById('thResult'),
    thTime: document.getElementById('thTime'),
    h3Accurate: document.getElementById('h3Accurate'),
    pAccurate: document.getElementById('pAccurate'),
  };

  const langToggle = document.getElementById('languageToggle');
  let currentLang = 'fa';

  function updateTexts(lang){
    const texts = translations[lang];
    document.documentElement.lang = lang === 'fa' ? 'fa' : 'en';

    elementsToTranslate.appTitle.textContent = texts.appTitle;
    elementsToTranslate.labelSize.textContent = texts.labelSize;
    elementsToTranslate.run.textContent = texts.run;
    elementsToTranslate.auto.textContent = texts.auto;
    elementsToTranslate.strongStatus.textContent = texts.strongStatus;
    elementsToTranslate.thSize.textContent = texts.thSize;
    elementsToTranslate.thResult.textContent = texts.thResult;
    elementsToTranslate.thTime.textContent = texts.thTime;
    elementsToTranslate.h3Accurate.textContent = texts.h3Accurate;
    elementsToTranslate.pAccurate.textContent = texts.pAccurate;

    const statusBox = document.getElementById('liveStatus');
    if (statusBox.textContent === translations.fa.statusNoTest || statusBox.textContent === translations.en.statusNoTest) {
      statusBox.textContent = texts.statusNoTest;
    }
    
    // Update summary
    updateSummary();
    
    // Toggle button label (shows current lang / other)
    langToggle.textContent = lang === 'fa' ? 'EN / FA' : 'FA / EN';
  }

  langToggle.addEventListener('click', () => {
    currentLang = currentLang === 'fa' ? 'en' : 'fa';
    updateTexts(currentLang);
  });

  // Theme toggle
  const themeToggle = document.getElementById('themeToggle');
  let currentTheme = 'dark';
  themeToggle.addEventListener('click', () => {
    if (currentTheme === 'dark') {
      document.body.classList.add('light-theme');
      themeToggle.textContent = 'ğŸŒ™ / ğŸ’¡';
      currentTheme = 'light';
    } else {
      document.body.classList.remove('light-theme');
      themeToggle.textContent = 'ğŸ’¡ / ğŸŒ™';
      currentTheme = 'dark';
    }
  });

  // Main logic
  const sizeInput = document.getElementById('size');
  const statusBox = document.getElementById('liveStatus');
  const resultsBody = document.querySelector('#results tbody');
  const btnRun = document.getElementById('run');
  const btnAuto = document.getElementById('auto');
  const summaryText = document.getElementById('summaryText');
  const recommendedMTU = document.getElementById('recommendedMTU');

  // Use a reliable testing endpoint
  // Note: Most CDNs and APIs don't respect MTU/DF flags in browser context
  // This test checks if data of specific size can be transferred, not actual MTU
  const service = "https://httpbin.org/bytes/";

  // Test results storage
  let testResults = {
    total: 0,
    success: 0,
    failed: 0,
    largestSuccessfulPayload: 0
  };

  function updateSummary() {
    const texts = translations[currentLang];
    
    if (testResults.total === 0) {
      summaryText.textContent = texts.summaryNoTests;
      recommendedMTU.textContent = '';
      return;
    }
    
    let summary = texts.summaryTestsDone
      .replace('{{total}}', testResults.total)
      .replace('{{success}}', testResults.success)
      .replace('{{failed}}', testResults.failed);
    
    summaryText.textContent = summary;
    
    if (testResults.largestSuccessfulPayload > 0) {
      const mtu = testResults.largestSuccessfulPayload + 28;
      let mtuText = texts.recommendedMTU
        .replace('{{mtu}}', mtu)
        .replace('{{payload}}', testResults.largestSuccessfulPayload);
      
      // Add warning for common MTU values
      if (mtu > 1500) {
        mtuText += " âš ï¸ (Ø¨Ø§Ù„Ø§ØªØ± Ø§Ø² MTU Ù…Ø¹Ù…ÙˆÙ„ÛŒ Ø§ØªØ±Ù†Øª)";
      } else if (mtu < 576) {
        mtuText += " âš ï¸ (Ø®ÛŒÙ„ÛŒ Ú©ÙˆÚ†Ú©ØŒ Ù…Ù…Ú©Ù† Ø§Ø³Øª Ù…Ø´Ú©Ù„Ø§Øª Ø§ØªØµØ§Ù„ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´ÛŒØ¯)";
      } else if (mtu >= 1300 && mtu <= 1500) {
        mtuText += " âœ… (Ù…Ù†Ø§Ø³Ø¨ Ø¨Ø±Ø§ÛŒ Ø¨ÛŒØ´ØªØ± Ø´Ø¨Ú©Ù‡â€ŒÙ‡Ø§)";
      }
      
      recommendedMTU.textContent = mtuText;
    } else {
      recommendedMTU.textContent = '';
    }
  }

  function setStatus(key, size, cls){
    const texts = translations[currentLang];
    let text;
    
    if (key === 'statusTesting') {
      text = (typeof texts.statusTesting === 'function') ? texts.statusTesting(size) : texts.statusTesting;
    } else if (key === 'statusSuccess') {
      text = (typeof texts.statusSuccess === 'function') ? texts.statusSuccess(size) : texts.statusSuccess;
    } else if (key === 'statusNetworkError') {
      text = texts.statusNetworkError;
    } else if (key === 'statusComplete') {
      text = texts.statusComplete;
    } else if (key === 'statusInvalidInput') {
      text = texts.statusInvalidInput;
    } else {
      text = texts.statusNoTest;
    }
    
    // Remove all status classes
    statusBox.classList.remove('status-default', 'status-ok', 'status-err', 'status-loading');
    
    // Add new class
    if (cls) {
      statusBox.classList.add(cls);
    } else {
      statusBox.classList.add('status-default');
    }
    
    statusBox.textContent = text;
  }

  function addRow(size, result, ms, isSuccess){
    const tr = document.createElement('tr');
    
    // Add appropriate class based on result
    let resultClass = 'result-unknown';
    if (isSuccess === true) {
      resultClass = 'result-success';
    } else if (isSuccess === false) {
      resultClass = 'result-failure';
    }
    
    tr.innerHTML = `
      <td>${size}</td>
      <td class="\( {resultClass}"> \){result}</td>
      <td>${ms !== null && ms !== undefined ? ms : "â€”"}</td>
    `;
    
    resultsBody.prepend(tr);
    
    // Update test results
    testResults.total++;
    if (isSuccess === true) {
      testResults.success++;
      if (size > testResults.largestSuccessfulPayload) {
        testResults.largestSuccessfulPayload = size;
      }
    } else if (isSuccess === false) {
      testResults.failed++;
    }
    
    updateSummary();
  }

  // Safe integer parsing with bounds
  function parsePayload(v){
    const n = Number.parseInt(String(v).trim(), 10);
    if (!Number.isFinite(n) || Number.isNaN(n)) return null;
    if (n < 1) return null;
    // arbitrary sanity bound to avoid insane requests
    if (n > 65535 - 28) return null; // keep payload + 28 within typical MTU limits
    return n;
  }

  async function run(size){
    const s = parsePayload(size);
    const texts = translations[currentLang];

    if (s === null) {
      setStatus("statusInvalidInput", null, "status-err");
      addRow(size, texts.statusInvalidInput, null, false);
      return false;
    }

    // compute MTU for display
    const computedMTU = s + 28;

    // Append unique query to reduce caching issues and force fresh fetch
    const url = service + s + `?cachebust=${Date.now()}`;

    setStatus("statusTesting", s, "status-loading");
    const start = performance.now();

    try {
      // Use abort controller for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
      
      const resp = await fetch(url, { 
        method: 'GET', 
        cache: 'no-cache', 
        mode: 'cors',
        signal: controller.signal 
      });
      
      clearTimeout(timeoutId);
      const ms = Math.round(performance.now() - start);

      if (!resp.ok) {
        const resultText = `HTTP error ${resp.status}`;
        addRow(s, resultText, ms, false);
        setStatus("statusNetworkError", null, "status-err");
        return false;
      }

      // read raw data
      const buf = await resp.arrayBuffer();
      const received = buf.byteLength;

      // On success, display both payload and computed MTU
      if (received === s) {
        const successText = `\( {texts.statusSuccess(s)} â€” MTU= \){computedMTU}`;
        addRow(s, successText, ms, true);
        setStatus("statusSuccess", s, "status-ok");
        return true;
      } else {
        // size mismatch
        const resultText = `Ø¹Ø¯Ù… ØªØ·Ø§Ø¨Ù‚: Ø¯Ø±ÛŒØ§ÙØª \( {received}/ \){s} â€” MTU Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯Ù‡: ${computedMTU}`;
        addRow(s, resultText, ms, false);
        setStatus("statusNetworkError", null, "status-err");
        return false;
      }
    } catch (e) {
      clearTimeout(timeoutId);
      const ms = Math.round(performance.now() - start);
      const msg = String(e && e.message ? e.message : e);
      // classify common fetch errors
      let resultText;
      if (msg.includes('abort') || msg.includes('timeout')) {
        resultText = `Timeout after ${ms}ms`;
      } else if (/network|failed|fetch/i.test(msg)) {
        resultText = texts.statusNetworkError;
      } else {
        resultText = `Error: \( {msg.substring(0, 50)} \){msg.length > 50 ? '...' : ''}`;
      }
      addRow(s, resultText, ms, false);
      setStatus("statusNetworkError", null, "status-err");
      return false;
    }
  }

  // Single run button
  btnRun.addEventListener('click', async () => {
    // Don't clear results for single test, just add to existing
    const s = sizeInput.value;
    await run(s);
  });

  // Auto multi-test
  btnAuto.addEventListener('click', async () => {
    // Clear results for fresh auto test
    resultsBody.innerHTML = "";
    testResults = {
      total: 0,
      success: 0,
      failed: 0,
      largestSuccessfulPayload: 0
    };
    updateSummary();
    
    // Test common payload sizes for typical MTU values
    const testSizes = [
      1472, // MTU 1500 (1500 - 28)
      1452, // MTU 1480
      1400,
      1300,
      1200,
      1100,
      1000,
      900,
      800,
      700,
      576,  // Minimum recommended
      500,
      400,
      300,
      200,
      100
    ];
    
    // disable buttons during auto run to prevent accidental re-click
    btnAuto.disabled = true;
    btnRun.disabled = true;
    btnAuto.textContent = currentLang === 'fa' ? 'Ø¯Ø±Ø­Ø§Ù„ ØªØ³Øª...' : 'Testing...';
    
    try {
      for (let i = 0; i < testSizes.length; i++) {
        const s = testSizes[i];
        await run(s);
        
        // small delay between tests to reduce burst load on remote server
        // Longer delay for larger sizes
        const delay = s > 1000 ? 500 : 300;
        await new Promise(r => setTimeout(r, delay));
      }
      setStatus("statusComplete", null, "status-ok");
    } finally {
      btnAuto.disabled = false;
      btnRun.disabled = false;
      btnAuto.textContent = translations[currentLang].auto;
    }
  });

  // Allow pressing Enter on input to run test
  sizeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      btnRun.click();
    }
  });

  // initial text setup
  updateTexts(currentLang);
  
  // Add disclaimer about browser limitations
  console.log("MTU Tester: Note that browsers cannot set DF flag, so this is not a true MTU test.");
  console.log("This tool tests data transfer size limits, not actual MTU fragmentation.");
})();
</script>
</body>
</html>
